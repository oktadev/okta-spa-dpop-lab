{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "3 - DPoP token",
  "nextTour": "",
  "steps": [
    {
      "file": "src/app/app.config.ts",
      "description": "## Enable DPoP\n\nWe need to enable DPoP for this Okta app. Enabling DPoP specifies that all requests made to the Okta APIs use DPoP. \n\nBack in your Okta org:\n  1. Navigate to **Applications** > **Applications**\n  2. Find the DPoP Okta OIDC app and select it \n  3. Open the **General** tab, find the **General Settings** section, and select **Edit**\n  4. Find the **Proof of possession** checkbox and enable \"Require Demonstrating Proof of Possession (DPoP) header in token requests\"\n  5. Select **Save**\n\nIn the OIDC configuration code, we need to enable DPoP. Add the following property or select the **Insert Code** button to add it for you:\n\n```ts\ndpop: true\n```\n\nSign in to the application and navigate to Users view again. Once again, we have an empty table and errors in the **Network** tab. üòê I guess we have to solve this again.\n\nOpen the **Application** tab in DevTool. Expand **Local storage** and select your app. Find `okta-token-storage` and expand `accessToken`. We see something new: the `tokenType` is now `DPoP`.\n\nThere's another component to DPoP requests ‚Äì asymmetric encryption. We sign proofs for our requests using a public/private keyset. In the **Application** tab, expand **IndexedDB** > **OktaAuthJS** and select **DPoPKeys**. We see a public and private `CryptoKey`. We'll discuss why this info isn't in local storage, but for now, please note that proofs get signed with a private key.\n\nNow, let's send DPoP-conformant API requests so we can see this at work.",
      "line": 16
    },
    {
      "file": "src/app/auth.interceptor.ts",
      "description": "## Add the required DPoP code imports\n\nWe need to add a few lines to our imports list. We'll use Okta's OIDC client library to set the DPoP headers in the HTTP request.\n\nAdd the following code or select the **Insert Code** button:\n\n```ts\nimport { DPoPHeaders } from '@okta/okta-auth-js';\nimport { defer, map, switchMap } from 'rxjs';\n```",
      "line": 5
    },
    {
      "file": "src/app/auth.interceptor.ts",
      "description": "## Add the DPoP headers to outgoing HTTP requests\n\nDPoP requests include two headers, the `Authorization` and `DPoP` headers. The `DPoP` header contains the proof, and the `Authorization` header contains the access token issued by the authorization server. We supply the request endpoint and the HTTP method that binds the request in the proof.\n\nAdd the following code or select **Insert Code** to add it automatically:\n\n```ts\n  const url = new URL(req.url);\n\n  return defer(() => oktaAuth.getDPoPAuthorizationHeaders({url: `${url.origin}${url.pathname}`, method: req.method})).pipe(\n    map((dpop: DPoPHeaders) =>  req.clone({\n      setHeaders: { ...dpop }\n    })),\n    switchMap((request) => next(request))\n  );\n```",
      "line": 21,
      "selection": {
        "start": {
          "line": 13,
          "character": 1
        },
        "end": {
          "line": 20,
          "character": 5
        }
      }
    },
    {
      "file": "src/app/auth.interceptor.ts",
      "description": "## Double check your work\n\nSelect [this link to run the unit test script that verifies your code configuration](command:codetour.sendTextToTerminal?[\"npm run test:dpop\"]).\n> Note this runs the following command: `npm run test:dpop`.\n\nIf you see the output\n\n`‚úì spec-app-dpop-auth.interceptor.spec.js (2 tests)`\n\nyou're ready for the next step.\n\n\nIf you don't see 2 passing tests, you must fix the configuration before continuing. Feel free to ask for help!",
      "line": 21
    },
    {
      "file": "src/app/auth.interceptor.ts",
      "description": "## Experiment with DPoP tokens\n\nNavigate to the users route in the app. Find the most recent `users?limit=10` request in DevTool's **Network** tab and inspect the request headers. You should see the header `Authorization: DPoP {yourAccessToken}` and the header `DPoP: {yourProof}`. \n\nLet's make the call to a different endpoint using the same tokens. We're varying both the endpoint and the caller.  \n\nIf you closed the Http Client tab, follow these steps to open the extension. Open the Http Client extension using VS Code's Command Palette. Open the Command Palette one of three ways:\n * MacOS - use the keyboard shortcut **Cmd+Shift+P**\n * Windows - use the keyboard shortcut **Ctrl+Shift+P** \n * To avoid keyboard shortcuts, select the three bars icon at the top left of the Codespace, then select **View** > **Command Palette...**\n\nStart typing \"Http\" and select the **Http Client: Open Http Client** option. You'll see a new tab for Http Client which makes HTTP requests from a user interface. \n\nFill in the following fields:\n  1. Leave the method as `GET`\n  2. Enter `https://{yourOktaDomain}/api/v1/apps`\n  3. Select **Headers** tab and\n     1. Enter `Authorization` as the **Key**\n     2. Open the app's DevTool's console drawer if it's closed; you'll need your access token again. Copy the following code and run it in the console to display the access token: \n   \n        ‚¨áÔ∏è\n\n        `console.log(JSON.parse(localStorage.getItem('okta-token-storage')).accessToken.accessToken)`\n\n        ‚¨ÜÔ∏è\n        \n     3. In the `Authorization` header, enter `DPoP {yourAccessToken}` as the **Value**\n     4. Add a new header by entering `DPoP` as the **Key**\n     5. Proofs have uniqueness constraints and aren't stored locally, so you'll need to grab the proof the old-fashioned way. Copy the proof from the HTTP request calling the `/users?limit=10` endpoint from the **Network** tab and find the **DPoP** request header. Ensure you copied the entire proof, not only the first section. Paste it in as the **Value**.\n\n**Send** the request. You should see a `400 Bad Request` error.\n\nLook at the response headers and find the `WWW-Authenticate` header. You'll see a descriptive error message stating that the `'htu' claim in the DPoP proof JWT is invalid`. We'll dive into the claims later, but the call fails, unlike the last time we did this using a bearer token.\n\nLet's try replaying the same request within DevTools. This time, we're using the same client and endpoint. So, no variables in this experiment, right?\n\nIn the app, navigate to Home and back to Users to force making another HTTP request. Find the most recent `/users` request in the **Network** tab. Right-click on the request and select **Replay XHR**.\n\nThe request fails! Select the failed request ‚Äì you'll see a `400 Bad Request`. If you look for the `WWW-Authenticate` response header, you'll see that the `The DPoP proof JWT has already been used.` as the error description. \n\nNice! It's looking like DPoP protects us from malicious sorts who try to make unauthorized calls to other endpoints and from token replay scenarios. DPoP tokens are locked down tight like a casino vault! Let's take a closer look at the tokens.\n\nOpen [jwt.io](command:vscode.open?[\"https://jwt.io\"]) in a new tab. Paste the proof into the JWT debugger. Hopefully you still have it in your clipboard. If not, copy it from the **Network** tab's `/users` request and find the `DPoP` request header. \n\nStarting from the **Decoded Header**, we see some interesting things:\n1. The token type (`typ`) is `dpop+jwt`, signifying that this is a DPoP JWT.\n2. The metadata in the JSON Web Key (`jwk`) claim is the signed public key info.\n   \nJackpot! We hit payday in the **Decoded Payload** (yes, these are Las Vegas jokes). ü¶óüòë All hilarious jokes aside, the proof binds the request metadata within it, decreasing the susceptibility of unauthorized use:\n1. The HTTP Method claim (`htm`) tracks the HTTP method of the request\n2. The HTTP URI (`htu`) has the request endpoint (doesn't include query params)\n3. When the proof was issued (`iat`)\n4. A unique JWT ID for the proof (`jti`)\n5. A hash of the access token (`ath`)\n\nMoving on to the access token, let's look at that now. You can copy the access token from the **Network** tab `Authorization` request header, or you can run \n\n‚¨áÔ∏è\n\n`console.log(JSON.parse(localStorage.getItem('okta-token-storage')).accessToken.accessToken)`\n\n‚¨ÜÔ∏è\n\nin the DevTool's console drawer. Paste the access token in the JWT debugger.\n\nThe notable thing we see here is the confirmation claim `cnf` in the payload, containing a hash of the DPoP public key. The access token and proof have information about each other, binding them together. ü™¢\n\nThe proof claims explain why our HTTP requests in the Http Client extension and replaying the XHR request failed:\n1. The proof works for a specific endpoint, so by changing the endpoint, we broke that constraint.\n2. The unique JWT ID prevents us from reusing the proof, as Okta's APIs verify that the ID is indeed unique.\n\nEven if Okta's APIs didn't verify the JWT ID, there's a fallback. The token's \"issued at time\" (`iat`) guards that proofs aren't created in advance or long-lived. The resource server can set the expiry time of proofs; quicker expiry times result in stronger security.\n\nThere's one security scenario we need to think about. Can someone create unauthorized proofs? Yes, they can if they get a hold of the private key. Okta's client SDK relies on two methods:\n1. Modern browsers support Web APIs such as Web Crypto. The Web Crypto API's `SubtleCrypto` library supports generating non-exportable keys. \n2. Modern browsers support `IndexedDB`. The `IndexedDB` browser storage supports storing `CryptoKeyPairs`, and queries to this storage return a reference to the object, not the raw key.\n\nThese methods for key storage make it impossible to exfiltrate information through cross-site scripting (XSS) style attacks. üéâ\n\nSign out from the app so we can start the next step from a fresh state. We need to take one more step to keep our keyset secure.",
      "line": 22
    },
    {
      "file": "src/app/app.component.ts",
      "description": "## Clean up the DPoP keyset\n\nIndexedDB helps keep the keyset safe, but it does have disadvantages. \n\nThe `IndexedDB` API is more challenging to work with than other forms of browser storage. The answer to dealing with painful and meticulous coding requirements doesn't mean we must suffer; we should leave the hard work to Okta's SDK team. üòÖ You always want to ensure you use a well-vetted, well-maintained OIDC client library that's either OIDC-certified or provided by your Identity Provider, regardless of whether you use bearer or DPoP tokens. However, it's **essential** for DPoP use cases as we don't want to write a custom implementation for OIDC plus DPoP specs and potentially miss something.\n\nAnother disadvantage is that the `IndexedDB` data persists across reloads, so we must clean up the keys. The SDK handles cleanup sign out, but users aren't guaranteed to sign out. They might leave their site tab open overnight and let the tokens expire. Let's not judge people who do that. üòá\n\nWe'll explicitly clean up keys when users sign in to ensure we start fresh. Add the following code (or select the **Insert Code** button):\n\n```ts\nawait this.oktaAuth.clearDPoPStorage(true);\n```\n\nIn the app, clear the **Network** tab and sign in again. DPoP has one extra security measure. For extra-sensitive requests, such as the `/token` request, the server may request that the client provide an additional value in their proof.\n\nFind the first `/token` request. This request failed with a `400 Bad Request`. Open the **Response** tab for the request to see the response payload `Authorization server requires nonce in DPoP proof.` Okta requires a nonce (number once) in the proof. The nonce allows the authorization server to ensure the proof is freshly minted and elevates the security measures beyond the issued time (`iat`) and JWT ID (`jti`). Because the nonce requires an extra handshake, we use this sparingly for extra-sensitive requests. Return the **Headers** tab and look at the **Response Headers**. You'll see a `Dpop-Nonce` response header. The client must re-request the `/token` using the nonce in the DPoP proof. Feel free to inspect the proof from the second `/token` request and find the `nonce` claim.\n\nNice! Your DPoP setup is so good, it makes other authorization methods feel like they're just bearer-ly getting by. üêª",
      "line": 25
    },
    {
      "file": "src/app/app.component.ts",
      "description": "## Learn more about DPoP and coding with Okta\n\nThank you for joining us for this lab! We hope you enjoyed it and we appreciate you spending time with us.\n\nFeedback is a gift, and we'd truly appreciate hearing from you about how we can improve this lab in the future. Please take a moment to scan the QR code and give us input on how we can enhance your experience in this lab and what courses/content you want to see.\n\nIf you'd like to learn more about DPoP, feel free to check out these great resources:\n\n* [How to Build Secure Okta Node.js Integrations with DPoP](command:vscode.open?[\"https://developer.okta.com/blog/2024/10/23/dpop-oauth-node\")\n* The [Okta Developer blog](command:vscode.open?[\"https://developer.okta.com/blog/\"])\n* The [Okta Developer YouTube channel](command:vscode.open?[\"https://www.youtube.com/c/OktaDev/\")\n* Learn more about building with Okta at [developer.okta.com](command:vscode.open?[\"https://developer.okta.com\"])\n",
      "line": 26
    }
  ]
}